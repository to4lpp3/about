---
title: "Episode 15: Peter Pezaris, CEO of Codestream"
publishDate: 2020-11-16T10:01-07:00
tags: [podcast]
slug: peter-pezaris
published: false
---

<!-- START AUDIO -->
<audio className="object-center" src="https://www.buzzsprout.com/1097978/6266917-peter-pezaris-ceo-of-codestream.mp3" controls={true} preload="none"></audio>
<!-- END AUDIO -->

<!-- START GUESTS -->
<span>Peter Pezaris, Beyang Liu</span>
<!-- END GUESTS -->

<!-- START SUMMARY -->
[Peter Pezaris](https://twitter.com/pezster) is the CEO and founder of [Codestream](https://www.codestream.com/), an editor plugin that's bringing code discussions and communication into your IDE. Codestream is starting by bringing GitHub PRs into your editor, but it has a novel vision for knowledge sharing that goes well beyond that. We talk about that vision, the shortcomings of existing communication tools for developers, and the challenges of building a uniform user experience on top of multiple editor APIs.
<!-- END SUMMARY -->

<!-- START SHOWNOTES -->
Codestream: https://www.codestream.com, https://twitter.com/teamcodestream

Peter Pezaris: https://twitter.com/pezster

Codestream source code: https://github.com/TeamCodeStream/codestream

Atari 800: https://en.wikipedia.org/wiki/Atari_8-bit_family#400/800_release

Fantasy Sports Hall of Fame (https://thefsga.org/fantasy-sports-hall-of-fame/), into which Peter was inducted after founding Daedalus World Wide Corporation (https://en.wikipedia.org/wiki/CBSSports.com), a company that built early versions of nfl.com and mlb.com

Co-founded Multiply (https://www.crunchbase.com/organization/multiply), acquired by Naspers (https://www.naspers.com/)

Co-founded Glip (https://glip.com), acquired by RingCentral: https://en.wikipedia.org/wiki/RingCentral

Working with GitHub in VS Code: https://code.visualstudio.com/docs/editor/github

Codestream for VS Code: https://marketplace.visualstudio.com/items?itemName=CodeStream.codestream

Codestream editor support: https://www.codestream.com/roadmap

Browser wars: https://en.wikipedia.org/wiki/Browser_wars

Atom: https://atom.io/

VS Code: https://code.visualstudio.com/

JetBrains: https://www.jetbrains.com/

Android Studio: https://developer.android.com/studio
<!-- END SHOWNOTES -->

<!-- START TRANSCRIPT -->
*This transcript was generated using auto-transcription software.*

Beyang:  all right. I'm here with Peter. Bazaaris the founder and CEO of code stream, a company that's changing the way that programmers communicate over code. Peter, thanks for being on the show.

Peter: thanks very much for having me.

Beyang: Awesome. So before we dive into coast dream and what it is and, uh, how it's changing the way that we can have discussions over code. Um, I always like to kick things off by asking people how did you first get into programming?

Peter: uh, it feels like a million years ago. Uh, I guess I first became interested in programming because my brother, my, I have an older brother he's six years older and he had a couple of computers and I pestered my parents to buy me an Atari 800. And back then, uh, back then, you know, storing programs was kind of a, uh, Challenge and it was expensive.

So I would write programs, but as soon as I turned the computer off, I would lose my program. So I asked for my birthday for a hard drive at a floppy drive rather. And I remember it because I had worked so hard on writing this program. It was like a Zurich, like Dungeons and dragons type thing. And so we brought the, the disc drive home.

And back then plug and play didn't exist. So I couldn't save my program because, you know, in order to, to plug in the floppy drive, I had to turn off the computer. Um, so that was my first intro. And that was, you know, back in the early days of my high school. And I remember when I applied to college, actually my college essay was titled, I'm not sure exactly what I'm going to be, but I'm no, I'm not going to be a computer scientist because I was actually applying as a physics major.

Uh, but then two years into college, I was like, you know what? I love programming. And I've been a software engineer ever since

Beyang: Awesome. And, uh, I guess, you know, the journey from there to code stream, uh, , you. founded a couple of software companies along the way,   care to share kind of a brief overview of, of that journey.

Peter: sure. Sure. Um, well I went to CMU Carnegie Mellon, and while I was there, uh, I made a whole bunch of friends and three of them in particular, we ended up working on wall street at different firms, uh, after graduating and one night over beers, we decided. Uh, we were at this bar talking about how much money bill Gates had.

And we decided that maybe instead of talking about his wealth, maybe we should talk about how we could create our own wealth. And so that night we decided to start a company that was in 1995 and I've had the really good fortune of working with those same three guys ever since. Uh, code stream is our fourth startup.

Uh, the first one was, uh, fantasy sports online. So, uh, kind of embarrassingly we're we're in the fantasy sports hall of fame. Um,

well, it's kind of funny because I think it was ESPN that ran a commercial about they've made a statute to like some dude who is like in the fantasy sports hall of fame.

And it's this like really skinny. Geeky looking guy and I'm like, Hey, that's that's me. Um, so that was the first business and we sold it to, uh, CBS sports. Um, and that was awesome because it was the early days of the internet. And we had a great opportunity. We actually built one of the first version of major league baseball.com.

We built the first version of nfl.com. And so we had the chance to, you know, be real, really at the forefront of, of the initial deployment of the web and using it as an information. Pathway where people would, would get all kinds of sports, news and information. Um, and then the bubble burst, right. And we all sort of experienced that.

And media companies stopped investing online. So we had to sort of reinvent ourselves. So we, we. Started our second company, that was a social media company called multiply that we sort of did a soft pivot pivot into social commerce. And we had a great exit with that company, selling it to Naspers, um, which is, uh, Massive global media company and our third company was clipped.

So we sold that to RingCentral Glip launched the same month as Slack with an almost identical product. And although we didn't enjoy the sort of rocket ship success that Slack did, um, we found a great partner in RingCentral and now our technology is powering all of RingCentral's messaging services. And, uh, and that led us, uh, so we've started three companies.

We sold all three successfully and now Coldstream is our fourth. And I can't say how fortunate I feel to be working with the same bunch of guys. They're all my best friends. And we've had a lot of success and a lot of fun along the way.

Beyang: Sounds awesome. It sounds like the dream team and, and I guess, a lot of developers I talked to, they kind of have this arc in their career where they work on a bunch of things where they're applying software to various domains. And then at the end, they come back to developer tools, which is kind of advancing the state of their own craft.

It seems like, the three of you have kind of followed that arc as well. 

Peter: Yeah. Yeah, for sure. And for us, it's, it's, it's definitely that story, but also a very targeted version of that story. Because if you think about the three businesses that we created, the first one is fancy sports online, which at its core is moving your love for sports online and making it more fun and more social. And then our second business was social media, which, you know, on its face, everybody understands that that's moving your social life online and making it more fun and more social. And then R right.

Beyang: socializing with got it. Got it.

Peter: Third business, which was competitors, Slack. That's essentially the same set of challenges, only in a different context.

Now we're making business communication. Online more fun and more social. And so we finally realized, you know, the one audience that we think is really underserved when it comes to moderate and modernizing communication flows is developers. And so that's a large part of the inspiration behind code stream was having built these systems for so many other audiences that were like, okay, let's, let's scratch our own itch here.

Beyang: Makes sense. So, you know, when I think about developer communication, , you know, I think of maybe a couple of different, , places that developers regularly communicate. , I think of, ,  code reviews and pull requests. I think of chat. , I think of maybe pair programming. , I think of just like pinging someone, well, I guess I already said chat or talk talking to the person next to you, although that's, that's increasingly hard, uh, I guess in, in kind of the post COVID, remote world, , I understand that code stream is none of those things.

It's kind of a new way of interacting and discussing code and, and sharing knowledge. So. I guess, you know, for the benefit of, uh, our listeners, most of whom I would imagine that have not yet heard of code stream or are not too familiar with it. what is it?

Peter: um, well, I can, the, the easiest way to describe code stream is where we started. And it's with a very simple premise, which is that if you're looking at code in your editor and you have a question about it, how do you ask that question? And I'm old enough to remember that. Let's let's put coding aside for a second and let's talk about, uh, office documents, like a word processor.

So if I'm in Microsoft word and I have a question about a sentence that I'm looking at, I'm old enough to remember what I used to have to do. And what I used to have to do is I would turn on track changes. I'd add a comment, I'd save the file and then I'd email it to my teammate who would then, you know, UN unpack the attachment, see what my comment was, and then email me back.

And if you think about it at its core, that's essentially what developers are doing today because we have an editor that we. View code. And if you have a question about that code, what engineering teams tell us today is that if they want to get an answer to a question about a block of code, they select the code and they copy it, paste it into Slack.

And in doing so you lose all of the context. You don't, you have to recreate that. So you have to say in this repository, in this file, which is in this directory, I have a question I'm on this branch and I'm looking at this code and, and tell me why function food is returning. No, for me. And then the person who asked that question, you know, has to stop what they're doing.

Switch over to Slack, get distracted by a whole bunch of things. Eventually they'll get back to you. And you know, so that level of deep context switching was something that we wanted to solve by embedding collaboration, right into the document offering tool in the same way that Google docs now is so much better than track changes and the old versions of Microsoft word.

So building that simple communication tool right into your programmers editor seems like such a no brainer that. You know, when we first came up with the idea, we're like, ah, somebody has definitely done this before. Right. Somebody must have. And yet in all our research, we found that that really nobody had attempted it, or at least not that we couldn't find any evidence of somebody having it done to it.

And once we got into it and tried to develop a prototype, we started to understand why. And there's basically two main reasons. The first reason is that. The way that typical development is done is that everybody has a copy of the source tree. So I'll have my copy of the repo and you'll have your copy of the repo.

And when I make changes, you don't immediately see those changes. So Google docs takes advantage of the fact that we're both looking at the same document. And so that makes it easy for me to select some sentence and then ask a question about it because we're both looking at the same thing. Well, that's not true for programmers.

So that's the first hurdle we had to overcome. And then the second hurdle we had to overcome was that, well, chances are, if you're on a team of any decent size, I'll be using one editor and some of my teammates will be using a different editor. So we don't really have control of the authorizing tool itself.

And we knew we didn't want to build our own editor and try to convince everybody to just switch over it. Cause that's a pretty big competitive landscape. There's a lot of engineering effort that's going into building. Programmers editors. And we didn't want to be the 51st editor on that list that tries to gain market share.

So what we decided was we would build code stream as a plugin for all the popular editors to provide a very simple capability, which is if you see some code and you don't understand it, you just select the code and you type your question works just like Google docs commenting does. And we've tried to hide all that complexity to make it really, really easy.

Beyang: got it. , I think that that immediately prompts a number of questions in my mind. So I, so like the vision you're going towards is Google docs, like experience, but in your own editor without kind of any, uh, extra mental overhead, right. , but I guess, like, how do you get around that issue that you mentioned earlier of everyone having a different view of the source tree?

Are you just kind of like pushing things up when someone makes a comment and then, you know, when another person wants to view that comment, they like pull that branch or, you know, how does that all work?

Peter: So what, what were the original, and this is back to the, sort of the, the, the idea behind code stream. The, the idea is we want to make it easy to answer a question about code that you're looking at. So you first select the code that you want to talk about. Right? And then you add your comment and similar to how Google docs does it.

Right? So you select the sentence, he slits like the code block. So when you do that, we capture all the context. Yeah. We need, in order to present that code block to the other people on your team, In a relevant way. So for example, if you're on branch, a and your teammates are on branch B, well, if the code is the same between branch and branch B, then we don't really have to do anything different.

Right. We can just sort of present that to the other person on the other side, the same way. If you've made some local changes, well, then we show them, we give them the opportunity. Like this is the code that Peter commented on. This is the code that you have, and here's the diff. And so you can write within the message body of my question.

You have little tabs, so you can see all three things. And so it's really presented in a way, you know, one way to think about it is that. You know, Slack or other communication tools all have what they're really, really good at. Like, I message is really good at sharing photos and talking about photos. Well, coach stream is kind of like a messaging service that's built for talking about code.

And so we've made a code block sort of the first class object in the conversation stream. And so we've given developers the tools to be able to understand the context of all the code that's being shared.

Beyang: Got it. And so is it more for, would you say asynchronous or synchronous communication? Is it like, you know, I have a question, some code, I make a comment and my colleague immediately gets a ping or a notification in their editor or is it. More, you know, I, I have a question, I ask it, and then sometime later, someone who will get like a batched, uh, notification, or maybe an email alert, and then they'll click, click into that and answer my question.

Peter: the way that we like to think about it is that, um, a lot of teams use Slack and zoom for internal communication. Those are sort of the two big exam, you know, they're competitors in each category. Um, we're a lot more like Slack. W w where you can ask asynchronous questions, you can ask a group of people, you know, as the whole development team.

Hey, does anybody know how this works? In which case? Maybe it's not an immediate response, but somebody will get back. You eventually, hopefully. Um, but yeah, you can also add, mention people in which case they will get a little toast notification, their editor, Hey, Peter needs your help, but this thing, 

uh, but importantly, we don't provide that sort of zoom, like.

Capability where it's more like pair programming. We think there are a lot of great tools for pair programming. We're not trying to compete in that space, but more of the, you know, synchronous and asynchronous, but text-based communication.

Beyang: got it. That makes sense. So if I'm using code stream, I have something like a feed perhaps of various comments that get added and then, uh, If someone mentions me, or if there's some other trigger that sets off like, Hey, you know, I want to get alerted on this type of comment right away that will immediately show up and I can go and respond to that.

Peter: that's exactly right. And it's probably worth mentioning that we do also have very robust. Integrations with Slack, Microsoft teams and just regular old email. So in addition to having that notification come through just the code stream interface or come right into your editor, if you prefer, or at your choice, you know, you can have these things ping your teammates through existing channels on Slack or through ad mentions.

Or you can even just DM one of your teammates, a question right from your editor. And the key is that's using your existing communication tools. And yet you don't have to do that context switch because code stream captures the context for you. So when you ask a question about that code, your teammates will know exactly what you're talking about.

Because when we share that question via Slack, we'll know what repo you're in, what branch you're on, what file you selected the code block. And we even provide a handy one click on the other side. So when you ask the question, your teammate just has to click a button and it opens up their favorite editor.

Right to the file that you're asking about scroll to the right position so they can look and see in their editor. Exactly. The code block that you're asking a question about.

Beyang: Yeah, that makes sense. It seems like, um, this mode of communication, it is most it's closest to, uh, the kind of turn around and ask your colleagues sitting next to you or ping someone on chat, uh, that kind of mode of communication. Uh, I'm curious though, if users of code stream also find it, uh, changing or effecting other modes of developer communication.

So. Um, concretely code review is, is something that, uh, you know, most teams do every single day. And, you know, D does the ability to, , ask better questions and get answers more quickly, take some of the burden off the code review process, , in your experience, or do you think these are pretty like distinct, , modes of communication that, you know, code review is pretty separate from what you're trying to tackle?

Peter: so that's a really interesting question. And, and one in which like, I'd like to dive in and talk about it a little bit, um, the. When we originally started code stream, we understood that there really wasn't any tool like it. There was no tool that made it easy to just ask questions about code without having to first make a change and then save your change and then committing the code and then pushing it and then creating a PR and have somebody pull it down and like request them as a reviewer.

And then they're doing a code review. There's so many steps to that process. That we wanted to take all the friction out of it and just make it super easy. Hey, why is this returning null for me? Right? Because there are so many clouds that we, our thesis was based around. If we can reduce the amount of friction, increase the frequency of developer communication, then yes, we could make code review easier at the end of your sprint.

Um, what we found was that the customers, when we first launched the customers that you're using code stream the most, um, Experienced that. And so we surveyed them and of our active customers, they told us on average, it reduced their code review time by 50%. And that was awesome. That was really great. Um, what we

Beyang: they were like answering questions before they got to code review or were they using it like in the context of a code review, like, Hey, I'm reviewing this diff and I'm going to hop into code stream to, to

Peter: a little bit, and that was the really surprising things. It was a little bit of both. Um, and our most active customers, when they, when we talk to them about how they were using code stream, they're actually using code stream as a sort of ad hoc code review tool to S to, to do code reviews before sort of the end of the sprint, or, or instead of using a get hub.com interface on a PRR, you know, get lab or a Bitbucket interface.

And. When we saw the lengths to which they had to sort of jump to use our in editor commenting tool to perform a code review. We said, well, why don't we try to make their lives a little bit easier? And so we built a code review tool right into code stream. And this was the start of 2020. Our, our big initiative was, uh, a code stream code review, which we, we call a feedback request and the idea behind.

Code streams. FRS is that it's a much lighter weight process than having to go through all the steps of creating a PR. And importantly, one of the things that we realized we could do, because we're in your editor, first of all, like creating the fr is like super simple. It's two clicks, right. And you're done and you've sent off the request.

But we've also developed the capability for you to request code on request, feedback on code. That's not committed yet, and that's not pushed yet because we're in your editor. We see what your diffs are. And at any point you can just, with two clicks of the mouse, you can just say, Hey, how does this look so far?

And you can share your current working changes, you know, including all the stuff in your working tree. And we package that up as a dif set. And ship it along with the feedback request object. And so your teammate can then visualize that in their editor and provide you line by line comments or comment, however they like.

And then that allows you to get sort of checkpoint reviews as you're, you're developing the code before, you know, you're ready to merge it in because what we've, what we hear from development teams a lot of times is that. Developers on the team. Wait too long to ask for help or wait too long to get a second pair of eyes on something.

And that's incredibly demotivating, especially if you're mentoring like a junior developer, if they've had their heads down for a whole week implementing some solution. And finally it's Friday and they're ready for their code review. And they've been like off base all week long, then, you know, it's, it's something that happens too often.

And it's a really tough thing for managers to have to deal with where, you know, you have to tell them to go redo the whole thing, which is incredibly de-motivating or you have to now accept all those technical debt into your code base. And it's, I, I think it's, it's something that we all deal with at some level all the time.

And anything we can do to try to reduce that and get feedback earlier in the process, um, is really important. And, and fundamentally the most important thing we can do to improve developer practices. And that's why companies like Google, you know, they rather famously. How their code reviews are an average of 26 lines, whatever it is.

And they merged things in within four hours. And so they've solved the problem a different way, which is to have these sort of micro PRS, although they call them, change this whatever. Um, and some people are able to do that, but, you know, we interviewed development teams all the time who still struggle with having big PRS that have big reviews at the end.

And we're trying to develop the tools that can help them avoid that.

Beyang: Yeah, totally. I always find it. It's challenging. There is a definite trade off between small and big PRS. I think the conventional wisdom has settled on like, okay, small PRS are better because if it's any larger than a couple hundred lines, it's going to be very difficult to review. But at the same time, if you think about, uh, Like the, the amount of the quality of the change that you can get across in a couple of hundred lines versus a couple thousand lines.

Right. That's very different. And so it almost feels like in a lot of cases, by limiting yourself to smaller PRS, you're kind of implicitly constraining your engineering team to make these incremental evolutionary changes. Whereas a lot of times, you know A lot of value can be added by, you know, one person saying like, Hey, I've been thinking about this area of the code or this problem for a long time, I'm going to make this big sweeping change.

Um, and I'm just going to go do it, but then you get this problem, like this giant PR that, , you know, no one else in the team feels they, they can review. And then that's the point at which the knowledge. Uh, the shared knowledge B begins to the, uh, siloed in the mind of, you know, the one engineer. And then of course, like the challenge is like, how do you spread that knowledge out, out to the rest of your team?

So it sounds like, like how would code stream kind of fit into that situation? Would I, as the engineer behind that big PR would I would just be like constantly getting feedback earlier on, on that PR or would I be answering questions about it kind of after the fact as people dive into that code?

Peter: there are three, three ways we can help in that situation. Um, the first way, which recovered is that, um, The, the code discussions can be easier. Um, you know, you can, while you're sort of digging in, you can get incremental feedback by these feedback requests. So importantly, feedback requests can be disconnected from commit cadence.

And that's something that we think is critically important because when you discuss code, I think putting artificial barriers of like, I have to commit and push in order to talk about this. Is incredibly limiting. Like, why not let people talk about code at any point in time, we think that's like foundational to better communication.

So that's the first way we can help. Um, the second way we can help, you know, you talked about information sharing and knowledge sharing. Well, one of the things that that code stream does that we haven't touched upon yet, and it's, it's kind of. Cool is that we realized that in developing this algorithm that allows us to communicate, communicate about any part of the code at any time, even across branches.

Well, we built an algorithm that will determine for any given version of a file for any commit Shaw for a given range within that file. Where does that range end up in a future version of the file?

Beyang: Hmm.

Peter: had to do that in order for this commenting to work. And it's a pretty sophisticated algorithm.

Beyang: That's a tricky problem.

Peter: It really is.

Um, but what it allows us to do is then save that common thread with that sort of logical location, even in future versions. And so we can keep a linkage between the conversation and the location. Even after mergers, after the code changes, you know, six months later, we still leave behind these annotation markers in the code base, letting you know, Hey, kit conversation took place here.

So we think that that. And, and because we developed the algorithm, we even can do that at your option with merge PR comment. Now, some people find that really useful. Some people find that less useful, but we can sort of resurface all of your merged PR comments, the comments on specific code blocks and allow you to see them and visualize them in your editor.

Beyang: so if I'm looking at a file and like, why the heck is it written that way I can, uh, click a button and go spelunking into the discussion history behind that file. Is that what you're saying? 

Peter: that's exactly right. And, and in fact, any, if that file contains any comments from any prior PRS or any comments from any code discussions or like from our FRS, our feedback requests. Or any just ad hoc questions of, you know, your, your teammate, Lisa, ask your teammate, Joe, Hey, how does this work? And Joe explains it to him.

So all of those conversations are available for you to visualize in your editor, wherever you're looking at the code. And so it, it can give you a much deeper history and more information about how the code base has evolved over time. And we give you the tools to manage that. Sort of basically what we're doing is we're capturing the exhaust fumes of the conversations that are already happening about your code base.

And then we give you the tools to manage that and organize it. So it can become a form of documentation about the history of the file or the component or the, the whole source tree. So that's the second way that we help in, in this sort of giant PR situation. And then the third way we can help, which actually the newest thing we built.

Um, is for get hub specifically, but get lab and Bitbucket are coming soon, we've built, uh, an all new PR interface right within your editor that we believe is, is, um, well, it's just a sensational experience because you get a nearly pixel perfect. Reimplementation of the github.com UI for PRS, but it's inside your IDE.

And what this allows you to do is basically anything you can do with a PR. Now you can do in the context of your editor. So you can see a list of all your PRS. We allow you to do like custom queries, so you can have multiple custom queries showing you exactly the PRS that you're interested in. You know, the ones that are assigned to you, the ones that you authored, the ones that you've been requested as a reviewer.

And then when you load that PR in your editor, We allow you to visualize the diffs, not only using, you know, everybody's sort of familiar with that one big, long list of diff hunks that, that get hub provides you. Right. So you can do that

Beyang: That doesn't scale well beyond a couple of files.

Peter: it doesn't, it doesn't. Um, and you, you, you have that view if you want it, but you also have, uh, sort of what, what you might be more accustomed to within editor, which is.

Your editors built in diff tool. So you can visualize the changes like in a side-by-side and that gives you access to all your editors, you know, bells and whistles, like jump to definition and, you know, find file and, and, um, you know, the, the key bindings that you like and, and code intelligence and integrated with all the PR commenting system.

So you can perform your PR code reviews. Within your editor. And so the reason that this helps is that you can make those incremental changes, knowing that, you know, it's less of a burden, it's less friction to get your teammates to interact with your PR because as soon as you request them as a reviewer, they're going to get that in editor toast notification.

Hey, Peter wants your feedback on this. Latest commit. They can do it right within their editor, just by clicking on that toast notification, send you the feedback back and all this still publishes through to get hub.com. So you still have your single source of truth for that. Uh, but it's a really pleasant way of working with PRS now.

Beyang: got it. That sounds really cool. Um, I know that GitHub has, uh, an integration into, well, maybe not every editor, but, uh, vs code. Um, have, have you tried that out at all? And do you know how, like this would compare to that experience?

Peter: So that their experiences kind of like, um, w what's the best analogy, like it's, it's, it's functional. It does the basics, but it's really limited to the basics. Um, and it also looks completely different than github.com. So if what you want is sort of a different

Beyang: like you're in your editor and you're just like viewing a different, your editor and making a comment

Peter: Right, right. Um, so PRS are X. It can get quite complicated.

I think there are some like 86 different event types that can happen in a PR timeline. And we support nearly all of them. Um, the, the editor Accenture that you're talking about supports, I believe like five out of the. 80 plus. So it's a really limited experience that allows you to do some of the basics and I'm sure they'll improve it over time.

But our goal with code streams, PR interface was first of all, to make it cross editor, we support 14 different IDs and the experience is identical across all of them. And the second is to be a hundred percent of what you can do on github.com. And in fact, we like to describe as 120% because we've taken.

Everything that you can do on get hub.com we've reimplemented it. And then we've added on top of it. For example, one of the things that you can't do on github.com and you can't do in their extension is you can't comment on anything. That's not a part of a defunk, um, which I always found to be incredibly limiting.

Like, if there's a part, right. If there's a part of the PR that like, you want to point somebody to some other part of the file or some other. File in the code base. You literally can't do it. So we build that right in. Cause um, you know, we have pretty advanced commenting functionality that we've built up over, over the versions of coaching that we developed.

So we make, make it really easy. You know, if you want to comment on any part of the code base, you just select the code, you type your comment and we'll add it to the PR.

Beyang: Yeah, that makes it makes a lot of sense. How, how do you ensure a uniformity of experience across all those? What'd you say it was like 13 different editors,

Peter: 14. Um, yeah, so that's, uh, that was a pretty heavy lift. Um,

Beyang: And is it is, I mean, like the naive way, I guess, would be just like have a web view that gets embedded into each of those. Uh, is it, is it like that or is it like you built out like separate native implementation for each editor?

Peter: It's a mix of both. Our client code is a three tiered architecture. The front end is a web view written and reacting TypeScript. Um, then there's a sort of agent process kind of like a demon that runs, that handles like communications, networking. It's got a local cache, that type of stuff. Lots of business logic in there.

And then the, and that's also written in TypeScript. And so those two layers are the same across every editor. And then there's a middle layer that speaks directly to the editor with the editors API language. Uh, and, and that's the real challenge because. Uh, I'm sure. You know, back, back in the days in the late nineties, we had the browser Wars where there was MSI II versus Netscape navigator, and then, you know, opera, and then, you know, Safari came along and as a web developer, you had a challenge because each.

One of them implemented their standards a little bit differently. And then, you know, Microsoft would introduce some new tag and it wouldn't be supported on the other. So you had websites that said, you know, this requires E six or whatever, and it was kind of a nightmare, but at least they were all trying to implement the same standard.

Like they were all using HTML and JavaScript and CSS. Well in the editor world, there's no such promise each. Editor has its own extension language, its own set of API APIs, its own everything. And so that was a really heavy lift to build those adapters that. At least for our purposes is, uh, you know, a layer on top of the editor that gives us a consistent API to develop, uh, to, you know, things like open this file.

Uh, what's the current selection. Um, you know, what, w what repo do you have open all of those things, you know, all of those API calls that we have now implemented across those editors, but what's nice about that is that it allows us when we build new functionality. We can deploy, you know, build it once and it's available across all 1490s.

Beyang: got it. What, what are the 1480s? Do you know offhand?

Peter: Yeah. So it's, it's 14 makes it sound like a little bit better than it is, but it's because it's, it's really four, um, or five. Yeah, maybe a little bit more than that. Todd I'll describe them. So there's vs code. That's easy one visual studio also pretty easy. Although, you know, let's take a second to congratulate Microsoft on yet another brilliant decision on marketing and branding because none of our customers understand that there's a difference between those editors and the two totally different things, but, okay.

So there's those two then there's Adam, um, which is, uh, Unfortunately, you know, while we're talking about editors, uh, uh, uh, it's, it's a shame that, that Adam hasn't stayed, uh, more relevant. I think vs code is really sort of taking a lot of the wind out of their sails. And I know a lot of people that really love Adam and it's, it's a shame that it's not getting the love that it maybe deserves.

Um, so those are the first three and then the rest of the JetBrains family of editors. And the reason it's a little bit more complicated is that JetBrains has 11 between PHP, storm, you know, sea lion, you know, all the WebStorm, uh, idea. They also have Android studio, but that's a different maintenance track.

It has different API APIs, so that's really kind of different. And then there's also. Some. Yeah. And there's also, and there are subtle differences between the different jet brains that we have to constantly work around. And there's also two major versions of all of those editors, one using cause they, they switched how they do web views.

And so we maintain, you know, five or six different versions of code stream for all the different JetBrains editors.

Beyang: Got it. Is there, uh, any roadmap for support for, uh, Emacs or VIM or X code?

Peter: We actually have some helping us out with an Emacs implementation. Um, it's worth noting that code stream is an open source project. We, we offer the client, uh, and the source code for the server as well. If you want to run your own backend. Um, although we do have a commercial version, uh, you know, code stream for business and code stream enterprise that.

You know, provides all the typical things that open core companies do. Um, so people are encouraged if you have, if your favorite editor isn't supported yet, uh, to contact us and, and help us build out support for that editor, we actually find that that middle layer with the. To connect to the editor. Isn't really the heavy lift.

Once you figure out what API is you need, and we do have that all documented sort of a list of things that you need to implement. A lot of it is just, can you get the editor to display a web view? Um, that's, that's a big part of it. So for an editor like Emacs, I'm not sure how satisfactory we'll be able to do that.

Beyang: makes sense. Makes sense. Um, so the kind of vision that you're describing for a developer communication? Um, well, I guess like someone once told me there's like two kinds of, uh, startups or new products, there is, better, faster, stronger, and brave new world,  better, faster, stronger being, you know, you take something existing and you just made a better version of it.

It's clearly better, but it's also clearly comparable to something that already exists. This strikes me as more brave new world where it's kind of this new mode of communicating and thinking and, my guess is that.

When you go out and you're looking for, , potential users and customers, you get a lot of blank stares because there's no thing that's immediately comparable that people can say like, ah, you know, it's like this, but better in these ways. And at least in our early days, we basically had to segment, , you know, anyone we talked to, we had to bucket.

Either into like this person gets it or this person doesn't and for the people that didn't get it, we said, well, you know, get to them later. Let's focus on the people who kind of really get it right now. And then we developed almost this kind of, um, Like machine learning algorithm, but like, you know, human learning, uh, for, for detecting, like who, who is going to get it, like, you know, we, we had a couple of features that were like, Oh, is this person, you know, used to work at Google they'll they'll, they'll get it.

Um, I'm wondering if, if you've gone through kind of the same sort of process, like, do you have like a profile of a, a developer that kind of immediately gets what you're trying to do? And just says like, Hey, like I want to use that.

Peter: we, we definitely have that experience as well. And I agree it's a brave new world type of product, um, because it's a new mode of communication. It's a, and what we have find found is that. The biggest challenge. Isn't so much that whether people get it immediately or not, because code stream, when, if I have the chance to demo code stream to somebody, I can almost guarantee that there'll be on the edge of their seat.

There'll be like chomping for, they'll ask, you know, when can I get this? I want to install it right now because it's such a basic well understood thing. Like communication is so fundamental and foundational and. It's also the case that most developers know that the tools are limited today. Like they know they can't chat about, um, code as easily as they want to.

Uh, and that there are, you know, we've, we have this slide in our, one of our presentation decks where it shows, okay, this is how to ask a question about code over Slack. And believe it or not, there's like 17 different steps between, you know, copying the code, going all tabbing to Slack, finding the right channel, pasting the code, describing where it came from going to your terminal, doing a get blamed, uh, you know, find out who wrote the code to go back to Slack to at mention the right person.

So, so on the left-hand column, there's the Slack interface, which has 17 steps. And then. Coach it's two steps, select the code, type your question. Right. And we automatically add mentioned the, the author of the code. So people get it right, right away. They get it. What our challenge in our brave new world is because of some of the limitations in current editors, we can't provide exactly the, the user interface that we want to.

So we're not able to surface. Code stream functionality, always at the moment that you want to do it. And so what we find is that the customers for us that really get it are the ones that not only understand that they want to use it, but they understand when to use it. Because when you're, when you're in a source code, art, natural, you know, software engineers by default, our natural inclination is to try to solve the problem and to try to figure it out code is, you know, We spent half of our time looking at code and trying to figure out what it does.

Right. It's it's our job. Right. And you have to sort of accept that. Hey, I could just ask and I'll probably get an answer that's faster than me trying to figure out, or I'll get a deeper understanding, but that's kind of antithetical to the whole development culture, which is that I'm supposed to figure it out.

Um, I'm. A professional developer, I'm supposed to understand code. And by admitting that I don't understand it, not only is that admitting my teammates, that I'm a weaker developer than they thought, but it's also going to bother them. So we all have to like break out of that mindset, I think, and realize that.

If the team were to share knowledge with each other, it's better for everybody. And if we can all just sort of put our egos aside and say, Hey, listen, it's going to be quicker for all of us. If we all just ask a lot more questions, um, that's how teams become more efficient. And, and we've seen it time after time with customers that adopt code stream a day able to adopt that mindset.

And then their productivity just goes through the roof.

Beyang: I, you know, I think what you're saying makes a lot of sense. , definitely  knowledge sharing and communication and development teams is one of the hardest problems to solve, especially in kind of the. The modern engineering environment where, you know, you're working with inside large organizations and there's a lot of contexts that can't fit inside one person's head.

But let me just play devil's advocate here for, for a moment. , because you, you know, as you mentioned, there are a lot of developers. I think it's part of our culture as developers to wanna figure things out for ourselves. Uh, it's also a bit of our culture to kind of want to cut out what we perceive as distractions.

Right. And so, You know, when you say that code stream is going to bring communication into my editor, that you know, I'm going to get, receive push notifications. When my colleagues have questions inside my editor, I can see for a lot of developers that can be the Mo that might strike them as like.

Like the editor is my last refuge from the noise of, of like all the different apps. You know, I got Slack, you know, pinging me. I got, you know, Twitter, social media, um, all these sources of like a distraction. And when I sit down to, to code, when I open up my editor, what I really want to do is focus on writing code.

And I don't want to get pinged. I don't want to push notification. I don't want to talk to anyone. I just want to kind of sit in my room and think, what would you say to that person?

Peter: it's uh, absolutely. You're you have a, a great reason to be concerned, um, that, you know, being in the zone. Is hugely important for developers, you know, maker's time as they call it, you need two hours of uninterrupted. You know, I'm deeply thinking about this problem. I'm writing code. I'm not distracted. And that's one of the real benefits of having a communication tool, specifically built for writing code, because what we've found, and this is not only our own feeling using code stream ourselves, but in talking to customers, is that if you're in the zone and you're writing code.

And you get a question about code. That's not going to break your flow. That's not going to break your focus. You're still. In the zone. What breaks your flow is when you get a Slack notification, that's about, you know, happy hour or a cat video, or you have to go to get hub.com, right? Because somebody requested your review on a PR and clicking into your web browser shows you that you have 

 17 other tabs open, and now you see a YouTube video and then you're, you know, and then you're gone, like you're lost. And then your calendar event pops up and I'll, should I have a meeting in 30 minutes? These are the things that really distract you and break your flow. But when you're talking about code, one of the things that you, you know, it's, it's the ultimate signal to noise ratio in that everything that code stream will feed you is somehow related to your code base.

And that is a great way to keep all the other stuff. Out of your development flow because what's the alternative. I mean, you still are going to have questions and today, if you're going to ask those via Slack, well, every time you mentioned somebody in Slack, you're pulling that developer out of their editor, pulling, sucking them into Slack, where they're going to get lost in their Slack notifications for the next 15 minutes.

Isn't it better to hit that developer about a coding question in their code editor so they can answer you and get back to coding. And so that's really the philosophy behind it. And we find that it absolutely works that way.

Beyang: So, what you're saying is I'm already getting distracted by Slack because people need to communicate with me and I need to answer their questions. Uh, and this is strictly better than Slack for code related questions.

Peter: Yeah, because it's only going to show you the code related stuff. Nobody is using code stream to share. Cat videos or, you know, or anything else there, there's no capability to do that, by the way, like you have to select code to comment on a ton unless you're like really?

Beyang: Can't paste like an animated GIF into

Peter: No, there's not none of that

Beyang: and code stream.

Peter: right?

No means we, we it's all serious business only built for developers. And by the way, you know, of course like you have control over your notifications as well. So like, if you don't want to get painted in your ID, you don't have to write, you can just turn that off. But in practice we find that it's, it's better to get pinged there about coding issues than it is to get pinged over Slack or via email, because then you're sucked out of your zone.

Beyang: You talked, you mentioned a bit about the constraints of working with, , the existing ideas today within w uh, what their API is and their, uh, gooey frameworks, , can provide from a user experience. Point of view.  How do you see that evolving in the future? Is there a vision of code stream that you're working towards in the future that you hope to realize, but you can't today, given those present constraints?

And if so, what do you think is the path forward? Is it just, you know, better, the IDs will improve their API APIs or, or do you think you might get back around to creating your own ID someday or perhaps some, some other application where we're more of that experience can live.

Peter: that's a good question. Um, I think that most of the issues that we've had have actually been resolved and what's fantastic is that, you know, five years from now a product like code stream couldn't have even existed because the editors weren't extensible enough from a UI perspective. And Adam really deserves credit as being the pioneer in this area.

That they made it trivial to create a web view. And so extension authors, people who build extensions for IDs had all kinds of incredible creativity around, you know, giving you user experiences that were very robust within your editor and vs code then took that mantle and ran with it and made it efficient enough that developers love their implementation.

And that gives us most of what we want. We're vs. Code is still a little bit tight is. Um, for example, it wasn't until the most recent version of vs code that we were allowed to have a web view in the sidebar. And the sidebar is where all the extensions live. So. The only place you could have a web view is in a, what they call a preview panel, which is an editor tab.

And so that's where coaching used to live until version one dot five last couple of weeks ago for various code. And because of that, it was difficult. That code stream would fall out of you because it would get hidden by on some other tab. And people wouldn't know how to find it, or why does this work differently than all my other extensions?

And so thankfully the vs code team implemented web view on the sidebar, which is awesome for us. So now costume has a home. It's got an icon on the activity bar. So you can always know where to click to get the code stream, but weirdly, uh, although there are badges on many of your other activity items there that show you how many, like things that are are there that need your attention.

You're not allowed to have a badge. On your own activity as a third party extension author, you can't put a Badger. So of course, you know, for as a communication tool, you need a badge. You need to know how many unread message, how many times have I didn't mentioned how many things do I have to look at that are new.

So we'd love to have a badge there. But they don't allow yet. So, you know, is that going to make or break the company? I don't think so, but we'd love, you know, and of course we've opened up an issue and thankfully, you know, Microsoft's been awesome to work with. They're an open source tool themselves, so we can even submit a PR.

Um, but, but I think the, the, the limitations are now becoming less and less and less. Um, and I think that. These modern editors like Adam and like vs code has now set the standard so high that extension authors are creating such rich and wonderful experiences that, you know, I couldn't imagine somebody else trying to come to market today with an editor that doesn't have a web view extensibility capability.

Um, so I think. Editors like, you know, editors are going to have to make a choice. Like, do I want to be completely locked down like Apple? And if I could take two seconds to just rant about Apple and please open up your editor, you know, X code, there's a lot of people using it, but a lot of extension authors want to make it better.

Um, so you'll have to choose either to be closed, be basically text only like VI or Emacs or sublime, or you're going to have to be an extensible editor. Like Visco Jeff JetBrains and others. And I think that's the direction the world is heading.

Beyang: so, w we've talked a bit about, um, putting web views inside IDs. Um, but there's also, you know, another trend which is bringing ideas to the web, uh, in the form of cloud IDs, uh, things like, you know, code spaces. And, um, I think there's, there's

a long. Coder.com. Exactly. Uh, what are your thoughts on, on that trend and will code stream integrate with those as well?

And, and if so, does that does the way that people use code stream change at all in a cloud ID versus a desktop native ID?

Peter: it may not seem, it may not immediately be. Obvious why, but I love the trend. Like I think it's awesome. I think for a lot of people, especially those who manage development environments, it's just so fantastic to be able to, you know, with one click, duplicate an environment and say you hire a new developer on the team and boom, they've got something to code against.

So that's great. Uh, I'm not sure how. You know, is it going to be 5% of the market or 50% of the market? I think it's a little too early to say whether people will just all move to developing in the cloud, in the web browser or not, you know, I'm intrigued, but whether they do or not all the same problems exist, you still need collaboration just because it's in a web browser, doesn't mean that all the problems that we had to solve for code stream have been solved. Like you still have to be able to communicate across branches. You still need to understand the context of what you're commenting on and you still need some sort of capability in the editor.

Um, so just by having it in the web doesn't mean those issues are solved. So I think there is, if anything, more opportunity for code stream in that environment, because people will expect that type of collaboration and yet it doesn't exist. So we can, we can still provide it, uh, when you're using, for example, vs code in, in a web browser.

Beyang: what does the next year of product feature releases for code stream? Look like.

Peter: well, we've gotten fantastic feedback, uh, from our GitHub integration. And, you know, it's, it's, we've just launched that recently and we're looking to improve it to maybe take that one 20% to one 30% or something, but we're also getting a lot of customer feedback from people who aren't using get hub. So those get those who love get lab in Bitbucket.

Um, uh, we, we want to give them some love and we know that that'll take us a few months to implement things to our standards, you know, to have a really full. Pull request and merge request experience right within your IDE for those services across all 14 of our IDs. So we're excited to do that. And you know, one of the things that that's great about collaboration solutions and especially ones that are, you know, as you said, like breaking new ground, um, is that there's no shortage of ideas and directions.

And so our roadmap has never been longer. Like we've got this incredibly long list of things that we want to build. And it's just limited by developer bandwidth. So that's one of the reasons that we went open source to try to, you know, open up our development process and, you know, to the extent that there are contributors out there that want to help us with our mission of building and delivering better communication to software teams around the world, uh, you know, we'd love.

Some help, but you know, there's, there's only so many hours in the day and you know, our team has been awesome, especially over the last several months, especially considering COVID of just delivering tons of new functionality with every new release. And I couldn't be more excited about where we are right now.

Beyang: Awesome. If someone's listening to this and you know, they really want to try out code stream, what should they do?

Peter: um, or team code stream on GitHub. So just, uh, our repos are, are public and, um, you know, just contact us about how to contribute. 

Beyang: My guest today has been Peter Polarez. Peter. Thanks for being on the show.

Peter: thanks very much. It was a pleasure. Uh, it was an awesome conversation. I really appreciate it. Thank you.
<!-- END TRANSCRIPT -->
